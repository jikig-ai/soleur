# Brainstorm: Autonomous PR Pipeline with Self-Healing Merges

**Date:** 2026-02-22
**Issue:** #214
**Status:** Captured
**Participants:** User, CTO Agent, Repo Research Analyst, Learnings Researcher

## What We're Building

A new skill (`merge-one-pr`) that automates the merge pipeline for PRs -- replacing `/ship` Phases 3.5-8. It handles fetching main, merging into the PR branch, auto-resolving conflicts (deterministic heuristics for version files + Claude-assisted for code conflicts), pushing, waiting for CI, merging, and cleaning up.

Phase 1 handles a single PR. Phase 2 (YAGNI, deferred) adds multi-PR batched mode with coordinated version bumps.

## Why This Approach

**Motivation (from Claude Code Insights -- 139 sessions):**
- Git operations (53 sessions) and PR merges (42 sessions) are the top two activities
- Merge conflicts are recurring friction (11 instances)
- Version bump conflicts from main advancing during sessions cause repeated rework

**Key design principles:**
- YAGNI: start with single-PR, defer queue orchestration
- Merge, not rebase: one conflict surface per PR, aligns with existing /ship pattern
- Compound as pre-condition: compound must have already run before PR enters pipeline
- Lights-out: fully autonomous, no human interaction during pipeline execution
- Claude-assisted conflict resolution: deterministic heuristics for known patterns, Claude for code conflicts, full trust with end-of-run reporting

## Key Decisions

1. **Autonomy level: Full lights-out.** Pipeline runs unattended. No pause gates for human approval. Results reported at the end.

2. **Compound gate: Pre-condition.** Compound must have already run before a PR enters the pipeline. The pipeline validates this by checking for unarchived KB artifacts. Rationale: compound creates new commits, which would invalidate CI and create a loop.

3. **Architecture: Start with merge-one-pr only (YAGNI).** Extract version-bump and conflict-resolver as primitives only if they naturally separate during implementation. Don't over-architect upfront. CTO recommended full decomposition into 4 primitives; we chose the simpler path.

4. **Git strategy: Merge, not rebase.** `git merge origin/main` into the PR branch. One conflict surface (vs rebase which can fail on every commit). Aligns with existing /ship Phase 3.5 pattern.

5. **Conflict resolution: Claude-assisted with full trust.** Known patterns (version files, CHANGELOG, component counts) use deterministic heuristics. Code conflicts use Claude. No human review gate -- results reported at end. Risk acknowledged: silent bad merges possible.

6. **Failure mode: Skip and continue.** On unresolvable conflict or CI failure, log the failure and continue with next PR (for future multi-PR mode). Report all failures at the end.

7. **Release behavior: Batched.** Pipeline handles version bumping, not the PR author. PRs enter the queue BEFORE version bump. After all PRs merge, one combined version bump triggers one release. This means the pipeline replaces /ship Phases 3.5-8.

8. **Pipeline scope: Replaces /ship tail.** PRs enter after compound+review (Phases 0-2). Pipeline handles: merge main, resolve conflicts, version bump, push, CI wait, merge, cleanup (Phases 3.5-8).

## Pipeline Design

### Pre-conditions (validated before starting)
- PR exists and is open
- Branch has been pushed to remote
- Compound has run (no unarchived KB artifacts for this feature slug)
- PR is reviewed (approved or no review required)
- No existing version bump on the branch (or strip it)

### Steps per PR
1. Fetch latest `origin/main`
2. Merge `origin/main` into PR branch
3. If conflicts:
   a. Version files (plugin.json, README badge, bug_report.yml): deterministic heuristic -- read version from main, keep higher
   b. CHANGELOG: keep both entries in descending version order (read full file with `git show HEAD:` to prevent truncation)
   c. Component counts: use feature branch count
   d. Code conflicts: Claude-assisted resolution
4. Push updated branch
5. Wait for CI (`gh pr checks --watch --fail-fast`)
6. Merge with `gh pr merge --squash`
7. Run `cleanup-merged` to remove worktree and branch

### Post-pipeline (batched release)
8. Apply combined version bump covering all merged PRs
9. Determine bump type: highest severity wins (any MINOR -> MINOR bump; all PATCH -> PATCH)
10. Update triad: plugin.json, CHANGELOG.md (combined entry), README.md
11. Commit and push directly to main (this is the one exception to "never commit on main")
12. Auto-release workflow fires once

## CTO Assessment Highlights

**Risk rating: HIGH** -- touches git state mutation, version coordination, autonomous merge.

**Key risks identified:**
- Git state corruption on partial failure (dirty working tree after failed merge)
- CHANGELOG is free-text markdown, not machine-parseable -- hardest file to auto-resolve
- Context/token limits for long pipelines (estimated 20-30k tokens per PR)
- Race condition if human merges to main during pipeline execution

**Mitigations accepted:**
- Always run `git status` after merge; if dirty, `git merge --abort` and skip
- Read full CHANGELOG from `git show HEAD:` before editing (prevents truncation)
- Start with single-PR to stay within context limits
- Pipeline assumes exclusive write access to main (document this constraint)

**CTO agent performance notes:**
- Assessment was thorough and well-structured
- Correctly identified the /compound timing tension before we discussed it
- Decomposition recommendation was sound even though we chose YAGNI
- Failure mode table was comprehensive
- No significant gaps in the technical assessment

## Open Questions

1. **Post-merge version bump on main:** Step 11 commits directly to main. This conflicts with the "never commit to main" guardrail. Options: (a) add a bypass flag to the guardrails hook, (b) create a temporary branch for the version bump and auto-merge it, (c) accept the exception and document it.

2. **Stripping existing version bumps:** If a PR already has a version bump committed, the pipeline needs to revert those changes before merging. How to reliably identify which commits are "version bump only" vs content?

3. **Multi-PR CHANGELOG consolidation:** When batching, should the combined CHANGELOG entry list each PR separately, or merge them into one narrative entry?

4. **Queue state persistence:** For future multi-PR mode, should the pipeline write a state file (`.claude/merge-queue-state.json`) for resumability if the session dies mid-pipeline?

## Learnings Informing This Design

| Learning | Impact on Design |
|----------|-----------------|
| CHANGELOG truncation during rebase conflict resolution | Must read full file with `git show HEAD:` before any edit |
| Parallel agents on main cause silent change loss | Must be strictly sequential, never parallel |
| Never use --delete-branch with parallel worktrees | Use `gh pr merge --squash` + `cleanup-merged` |
| Stale worktrees accumulate across sessions | Run `cleanup-merged` after EVERY successful merge |
| Version bump intent, not exact numbers | Defer version determination to merge time |
| Review and compound before commit | Compound is pre-condition, not pipeline step |
